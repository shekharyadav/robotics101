{
    "mode": "Text",
    "hardwareTarget": "brain",
    "textContent": '#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_drive_smart = Motor(Ports.PORT6, 3.0, False)\nright_drive_smart = Motor(Ports.PORT12, 3.0, True)\n\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 200)\ncontroller = Controller()\nBallShooter_right = Motor(Ports.PORT3, False)\nBallShooter_left = Motor(Ports.PORT10, True)\nLowerCollector = Motor(Ports.PORT11, True)\nUpperCollector = Motor(Ports.PORT5, False)\npneumatic_one = Pneumatic(Ports.PORT1)\nlight_up_first = Touchled(Ports.PORT2)\nlight_up_second = Touchled(Ports.PORT9)\nball_ready = Distance(Ports.PORT7)\nball_loaded = Distance(Ports.PORT8)\npneumatic_two = Pneumatic(Ports.PORT4)\n\n\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n    \n# Initialize random seed \ninitializeRandomSeed()\n\nvexcode_initial_drivetrain_calibration_completed = False\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    global vexcode_initial_drivetrain_calibration_completed\n    if not vexcode_initial_drivetrain_calibration_completed:\n        pneumatic_one.pump_off()\n        pneumatic_two.pump_off()\n    sleep(200, MSEC)\n    brain.screen.print("Calibrating")\n    brain.screen.next_row()\n    brain.screen.print("Inertial")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    if not vexcode_initial_drivetrain_calibration_completed:\n        pneumatic_one.pump_on()\n        pneumatic_two.pump_on()\n    vexcode_initial_drivetrain_calibration_completed = True\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n\n# Calibrate the Drivetrain\ncalibrate_drivetrain()\n\n\n\n# define variables used for controlling motors based on controller inputs\ndrivetrain_l_needs_to_be_stopped_controller = False\ndrivetrain_r_needs_to_be_stopped_controller = False\n\n# define a task that will handle monitoring inputs from controller\ndef rc_auto_loop_function_controller():\n    global drivetrain_l_needs_to_be_stopped_controller, drivetrain_r_needs_to_be_stopped_controller, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axisA + axisC\n            # right = axisA - axisC\n            drivetrain_left_side_speed = controller.axisA.position() + controller.axisC.position()\n            drivetrain_right_side_speed = controller.axisA.position() - controller.axisC.position()\n            \n            # check if the value is inside of the deadband range\n            if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n                # check if the left motor has already been stopped\n                if drivetrain_l_needs_to_be_stopped_controller:\n                    # stop the left drive motor\n                    left_drive_smart.stop()\n                    # tell the code that the left motor has been stopped\n                    drivetrain_l_needs_to_be_stopped_controller = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the left motor next\n                # time the input is in the deadband range\n                drivetrain_l_needs_to_be_stopped_controller = True\n            # check if the value is inside of the deadband range\n            if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n                # check if the right motor has already been stopped\n                if drivetrain_r_needs_to_be_stopped_controller:\n                    # stop the right drive motor\n                    right_drive_smart.stop()\n                    # tell the code that the right motor has been stopped\n                    drivetrain_r_needs_to_be_stopped_controller = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the right motor next\n                # time the input is in the deadband range\n                drivetrain_r_needs_to_be_stopped_controller = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_l_needs_to_be_stopped_controller:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_r_needs_to_be_stopped_controller:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller = Thread(rc_auto_loop_function_controller)\n\n#endregion VEXcode Generated Robot Configuration\n\n# Variable controls if collector should be stopped\ncollector_stopped = False\n\n# Variable informs if the collector is running or stopped\nis_collector_stopped = False\n\n# variable controls if autonomous second function should be running or notv\nis_autonomous_second_running = False\n\n# Drive train velocity\nDRIVE_VELOCITY = 60\n\n# shooter speed (flywheel velocity)\n# High velocity will make the ball shoot higher and further\n# low velocity will make the ball shoot low\nSHOOTER_SPEED = 75\n\n# Restarts the ball shooter\ndef restart_ball_shooter():\n    BallShooter_right.stop()\n    BallShooter_left.stop()\n    BallShooter_right.spin_for(REVERSE, 900000, DEGREES, wait=False) \n    BallShooter_left.spin_for(REVERSE, 900000, DEGREES, wait=False)\n\n# Set the ball shooters speed to high speed and restart the flywheels (ball shooter) so new velocity takes effect\n# This is unnecessary code now because we are not using speed to control the low/high goals\ndef set_shoot_higher():\n    brain.play_sound(SoundType.SIREN)\n    BallShooter_right.set_velocity(SHOOTER_SPEED, PERCENT)\n    BallShooter_left.set_velocity(SHOOTER_SPEED, PERCENT)\n    restart_ball_shooter()\n\n# Set the shooting mechanism to high position\ndef set_shoot_high():\n    brain.play_sound(SoundType.SIREN)\n    pneumatic_two.extend(CYLINDER1)\n    pneumatic_two.extend(CYLINDER2)\n    \n# Drops the shooting mechanism to low position\n# in this position the ball automatically (gravity) moves to the flywheel\n# so all we have to do is set the shooting mechanism to low position and ball will shoot\n# We then reset the shooting mechanism to point at high position\ndef set_shoot_low():\n    brain.play_sound(SoundType.ALARM2)\n    global collector_stopped\n    collector_stopped = True\n    pneumatic_two.retract(CYLINDER1)\n    pneumatic_two.retract(CYLINDER2)\n    wait(0.5,SECONDS)\n    pneumatic_two.extend(CYLINDER1)\n    pneumatic_two.extend(CYLINDER2)\n    wait(1,SECONDS)\n    collector_stopped = False\n    \n# extends the penuamtics to loading position so a new ball can be loaded\ndef load():\n    pneumatic_one.extend(CYLINDER1)\n    pneumatic_one.extend(CYLINDER2)\n\n# Retracts the penumatics to move the ball towards the flywheels\ndef shoot():\n    pneumatic_one.retract(CYLINDER1)\n    pneumatic_one.retract(CYLINDER2)\n\n# Stops the collectors (so as to transfer most power to the shooter)\n# Shoots by retracting the penumatics and then extending them again\n# starts the collector again\ndef shoot_and_load():\n    global collector_stopped\n    collector_stopped = True\n    wait(.5, SECONDS)\n    shoot()\n    wait(.5,SECONDS)\n    load()\n    collector_stopped = False\n\n# Starts collecting\ndef collector_collect():\n    LowerCollector.spin_for(FORWARD, 90000, DEGREES, wait=False)\n    UpperCollector.spin_for(FORWARD, 90000, DEGREES, wait=False)\n\n# Reverses the collector direction to spit the balls out\ndef collector_spit_out():\n    LowerCollector.spin_for(REVERSE, 90000, DEGREES, wait=False)\n    UpperCollector.spin_for(REVERSE, 90000, DEGREES, wait=False)\n\n# stops both the collectors\ndef collector_stop():\n    LowerCollector.stop()\n    UpperCollector.stop()\n\n# this is the controller event loop\n# it runs behind the scenes periodically every 100 ms\n# it checks if the balls are loaded if so then stops the collector\n# if either of the ball is not loaded it will start the collector\n# if the variable collector_stopped=True it will also stop the collector\ndef run_collector_controller():\n    global is_collector_stopped\n    if collector_stopped:\n        collector_stop()\n        is_collector_stopped = True\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1, 1)\n        brain.screen.print("csV")\n    else:\n        # check if both ball_loaded and ball_ready is true then we stop \n        # otherwise we start collecting again\n        if ball_loaded.object_distance(MM) < 20 and ball_ready.object_distance(MM) < 50:\n            collector_stop()\n            is_collector_stopped = True\n            brain.screen.clear_screen()\n            brain.screen.set_cursor(1, 1)\n            brain.screen.print("csB")\n        else:\n            collector_collect()\n            is_collector_stopped = False\n            brain.screen.clear_screen()\n            brain.screen.set_cursor(1, 1)\n            brain.screen.print("cRun")\n    \n    # trigger the next run\n    brain.timer.event(run_collector_controller, 100)\n\n# first autonomous function, its goal is to take two balls\n# and score the high and low goals only then it stops\n# the user must then transfer the robot to the other side\n# and start the second program\ndef start_autonomous_first():\n    start_robot()\n\n    drivetrain.set_drive_velocity(DRIVE_VELOCITY, PERCENT)\n    drivetrain.set_stopping(COAST)\n    brain.play_sound(SoundType.SIREN)\n\n    set_shoot_higher()\n    \n    # wait for both balls to load, the collector will stop then\n    while not is_collector_stopped:\n        wait(0.1, SECONDS)\n\n    drivetrain.drive_for(FORWARD, 50, INCHES ,wait=False)\n    wait(3, SECONDS)\n    # drivetrain.stop()\n    set_shoot_low()\n    wait(2.5, SECONDS)\n    shoot_and_load()\n    stop_robot()\n\n# Wait for the collector to stop or the a timeout of 3 second happens\ndef wait_for_collector_with_timeout():\n    count = 0\n    while not is_collector_stopped and count <= 30 and is_autonomous_second_running:\n        wait(0.1, SECONDS)\n        if count==10 or count==20 or count==30:\n            brain.play_sound(SoundType.TADA)    \n        count=count+1    \n\n# when the light up sensor is pressed it starts the second autonomous function\n# if the sensor is pressed again it will stop the function by setting is_autonomous_second_running = False\ndef toggle_autonomous_second():\n    global is_autonomous_second_running\n    if is_autonomous_second_running:\n        light_up_second.set_color(Color.YELLOW)\n        brain.play_sound(SoundType.POWER_DOWN)\n        stop_robot()\n        is_autonomous_second_running = False\n    else:\n        brain.play_sound(SoundType.ALARM)\n        light_up_second.set_color(Color.RED)\n        is_autonomous_second_running = True\n        global collector_stopped\n        global is_collector_stopped\n        start_robot()\n        collector_stopped = False\n        is_collector_stopped = False        \n        # do not call the start_autonomous_second in this function, it will block the sensor callback function\n        brain.timer.event(start_autonomous_second, 10)\n\n# Second autonomus code, its goal is to score low and high goals\n# then run in a forever loop of collecting two balls and shooting them high\n# the robot has a timeout of 3 seconds, if balls are not loaded within 3 seconds\n# the robot will proceed to shoot them\n# note this function will quit if is_autonomous_second_running is set to False\ndef start_autonomous_second():\n    # set drivetrain velocity for autonomous (different then manual)\n    drivetrain.set_drive_velocity(DRIVE_VELOCITY, PERCENT)\n    drivetrain.set_stopping(COAST)\n    brain.play_sound(SoundType.SIREN)\n    set_shoot_higher()\n\n\n    # wait for both balls to load, the collector will stop then\n    wait_for_collector_with_timeout()\n    if not is_autonomous_second_running:\n        return\n    # drive forward again\n    drivetrain.drive_for(FORWARD, 50, INCHES ,wait=False)\n    if not is_autonomous_second_running:\n        return\n    wait(2.5, SECONDS)\n    #drivetrain.stop()\n    brain.play_sound(SoundType.ALARM2)\n    if not is_autonomous_second_running:\n        return\n    set_shoot_low()\n    if not is_autonomous_second_running:\n        return\n    wait(1.75, SECONDS)\n    if not is_autonomous_second_running:\n        return\n    shoot_and_load()\n    if not is_autonomous_second_running:\n        return\n\n    drivetrain.drive_for(REVERSE, 28, INCHES, True)\n\n    while is_autonomous_second_running:\n        # wait for both balls to load, the collector will stop then\n        # add a counter so we don\'t wait for ever\n        wait_for_collector_with_timeout()\n        if not is_autonomous_second_running:\n            return\n        \n        # drive forward again\n        drivetrain.drive_for(FORWARD, 50, INCHES ,wait=False)\n        wait(2, SECONDS)\n        if not is_autonomous_second_running:\n            return\n        drivetrain.stop()\n        brain.play_sound(SoundType.ALARM2)        \n        shoot_and_load()\n        if not is_autonomous_second_running:\n            return        \n        wait(1.75, SECONDS)\n        if not is_autonomous_second_running:\n            return        \n        shoot_and_load()\n        if not is_autonomous_second_running:\n            return        \n        drivetrain.drive_for(REVERSE, 28, INCHES, True)\n\n\n# Starts the moving parts of the robot including pneumatic pump\ndef start_robot():\n    global collector_stopped\n    global is_collector_stopped\n    collector_stopped = False\n    is_collector_stopped = False\n    restart_ball_shooter()\n    pneumatic_one.pump_on()\n\n# This stops all moving parts of the robot including the pneumatic\n# this does not stop the collector event loop which will continue running\n# It uses the collector_stopped variable to inform the collector event loop that it should \n# stop the collector\ndef stop_robot():\n     global collector_stopped\n     global is_collector_stopped\n     collector_stopped=True\n     is_collector_stopped = True\n     drivetrain.stop()\n     BallShooter_right.stop()\n     BallShooter_left.stop()\n     pneumatic_one.pump_off()\n\n# This method is called when program is started\ndef when_started():\n    light_up_first.set_color(Color.GREEN)\n    light_up_second.set_color(Color.YELLOW)\n\n    drivetrain.set_stopping(COAST)\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(27, PERCENT)\n    BallShooter_right.set_stopping(COAST)\n    BallShooter_left.set_stopping(COAST)\n    BallShooter_right.set_max_torque(100, PERCENT)\n    BallShooter_left.set_max_torque(100, PERCENT)\n    BallShooter_right.set_velocity(SHOOTER_SPEED, PERCENT)\n    BallShooter_left.set_velocity(SHOOTER_SPEED, PERCENT)\n\n    LowerCollector.set_max_torque(100, PERCENT)\n    LowerCollector.set_velocity(100, PERCENT)\n    LowerCollector.set_stopping(HOLD)\n    UpperCollector.set_max_torque(100, PERCENT)\n    UpperCollector.set_velocity(100, PERCENT)\n    UpperCollector.set_stopping(HOLD)\n\n    #controller stuff\n    controller.buttonRUp.pressed(collector_collect)\n    controller.buttonRDown.pressed(collector_spit_out)\n\n    controller.buttonFUp.pressed(shoot_and_load)\n    controller.buttonFDown.pressed(set_shoot_low)\n    controller.buttonEDown.pressed(collector_stop)\n\n    # controller.buttonEUp.pressed(shoot_and_load)\n    controller.buttonLUp.pressed(start_robot)\n    controller.buttonLDown.pressed(stop_robot)\n\n    # Autonmous callback\n    light_up_first.pressed(start_autonomous_first)\n    light_up_second.pressed(toggle_autonomous_second)\n\n    # Start the collector controller loop/\n    # This loop runs periodically every 100 ms\n    # it checks if the balls are loaded if so then stops the collector\n    # if either of the balls is not loaded it starts the collector\n    # if the variable collector_stopped is True then it also stops the collector\n    # use this variable collector_stopped if you want to stop the collector\n    # regardless of if ball is loaded or not\n    global collector_stopped\n    collector_stopped=True\n    brain.timer.event(run_collector_controller, 100)\n\nwhen_started()\n# pandas rule!!!!!!!!!!!!!\n# hamsters rule!!!!!!!!\n# \n',
    "textLanguage": "python",
    "robotConfig": [
        {
            "port": [6, 12, 0],
            "name": "drivetrain",
            "customName": false,
            "deviceType": "Drivetrain",
            "deviceClass": "smartdrive",
            "setting": {
                "type": "2-motor",
                "wheelSize": "200mm",
                "gearRatio": "3:1",
                "direction": "fwd",
                "gyroType": "integrated",
                "width": "173",
                "unit": "mm",
                "wheelbase": "76",
                "wheelbaseUnit": "mm",
                "xOffset": "0",
                "yOffset": "0",
                "thetaOffset": "0",
            },
            "triportSourcePort": 22,
        },
        {
            "port": [],
            "name": "controller",
            "customName": false,
            "deviceType": "Controller",
            "deviceClass": "controller",
            "setting": {
                "left": "",
                "leftDir": "false",
                "right": "",
                "rightDir": "false",
                "e": "",
                "eDir": "false",
                "f": "",
                "fDir": "false",
                "l3r3": "",
                "l3r3Dir": "false",
                "drive": "split",
            },
            "triportSourcePort": 22,
        },
        {
            "port": [3],
            "name": "BallShooter_right",
            "customName": true,
            "deviceType": "Motor",
            "deviceClass": "motor",
            "setting": {"reversed": "false", "fwd": "forward", "rev": "reverse"},
            "triportSourcePort": 22,
        },
        {
            "port": [10],
            "name": "BallShooter_left",
            "customName": true,
            "deviceType": "Motor",
            "deviceClass": "motor",
            "setting": {"reversed": "true", "fwd": "forward", "rev": "reverse"},
            "triportSourcePort": 22,
        },
        {
            "port": [11],
            "name": "LowerCollector",
            "customName": true,
            "deviceType": "Motor",
            "deviceClass": "motor",
            "setting": {"reversed": "true", "fwd": "forward", "rev": "reverse"},
            "triportSourcePort": 22,
        },
        {
            "port": [5],
            "name": "UpperCollector",
            "customName": true,
            "deviceType": "Motor",
            "deviceClass": "motor",
            "setting": {"reversed": "false", "fwd": "forward", "rev": "reverse"},
            "triportSourcePort": 22,
        },
        {
            "port": [1],
            "name": "pneumatic_one",
            "customName": true,
            "deviceType": "Pneumatic",
            "deviceClass": "pneumatic",
            "setting": {
                "cylinder1": "cylinder1",
                "cylinder2": "cylinder2",
                "cylinder1_reversed": "false",
                "cylinder2_reversed": "false",
                "cylinder3": "",
                "cylinder4": "",
            },
            "triportSourcePort": 22,
        },
        {
            "port": [2],
            "name": "light_up_first",
            "customName": true,
            "deviceType": "TouchLED",
            "deviceClass": "touchled",
            "setting": {},
            "triportSourcePort": 22,
        },
        {
            "port": [9],
            "name": "light_up_second",
            "customName": true,
            "deviceType": "TouchLED",
            "deviceClass": "touchled",
            "setting": {},
            "triportSourcePort": 22,
        },
        {
            "port": [7],
            "name": "ball_ready",
            "customName": true,
            "deviceType": "Distance",
            "deviceClass": "distance",
            "setting": {},
            "triportSourcePort": 22,
        },
        {
            "port": [8],
            "name": "ball_loaded",
            "customName": true,
            "deviceType": "Distance",
            "deviceClass": "distance",
            "setting": {},
            "triportSourcePort": 22,
        },
        {
            "port": [4],
            "name": "pneumatic_two",
            "customName": true,
            "deviceType": "Pneumatic",
            "deviceClass": "pneumatic",
            "setting": {
                "cylinder1": "cylinder1",
                "cylinder2": "cylinder2",
                "cylinder1_reversed": "false",
                "cylinder2_reversed": "false",
                "cylinder3": "",
                "cylinder4": "",
            },
            "triportSourcePort": 22,
        },
    ],
    "slot": 0,
    "platform": "IQ",
    "sdkVersion": "20230818.11.00.00",
    "appVersion": "4.0.7",
    "minVersion": "3.0.0",
    "fileFormat": "2.0.0",
    "targetBrainGen": "Second",
    "v5SoundsEnabled": false,
    "target": "Physical",
}
